import json
import os
import re

from SCons.Util import WhereIs

from platform_methods import get_build_version


def run_closure_compiler(target, source, env, for_signature):
    closure_bin = os.path.join(
        os.path.dirname(WhereIs("emcc")),
        "node_modules",
        ".bin",
        "google-closure-compiler",
    )
    cmd = [WhereIs("node"), closure_bin]
    cmd.extend(["--compilation_level", "SIMPLE"])
    cmd.extend(["--assume_function_wrapper", "false"])

    for f in env["JSEXTERNS"]:
        cmd.extend(["--externs", f.get_abspath()])
    for f in source:
        cmd.extend(["--js", f.get_abspath()])
    cmd.extend(["--js_output_file", target[0].get_abspath()])

    # `--language_out` wasn't specified, which meant that the Closure compiler
    # would generate modern JS by default (ECMASCRIPT_NEXT or STABLE).
    # This would break compatibility regardless of flags like -sLEGACY_VM_SUPPORT or
    # -sMIN_X_VERSION flags.
    # By specifying `--language_out,` this tells Closure:
    # "Transpile the output down to ES2015 compatibility"
    if env["arch"] == "wasm32":
        cmd.extend(["--language_out", "ECMASCRIPT_2015"])
    else:
        cmd.extend(["--language_out", "ECMASCRIPT_2020"])
    return " ".join(cmd)


def create_engine_file(env, target, source, externs, threads_enabled):
    if env["use_closure_compiler"]:
        return env.BuildJS(target, source, JSEXTERNS=externs)
    subst_dict = {"___GODOT_THREADS_ENABLED": "true" if threads_enabled else "false"}
    return env.Substfile(target=target, source=[env.File(s) for s in source], SUBST_DICT=subst_dict)

def fix_optional_chaining(target, source, env):
    """
    Fix optional chaining syntax that's incompatible with older browsers.
    This function handles multiple patterns that might be generated by Emscripten/Closure.
    """
    js_path = str(target[0])

    try:
        with open(js_path, "r", encoding="utf-8") as f:
            content = f.read()

        original_content = content

        # Pattern 1: document.currentScript?.src
        content = re.sub(
            r"document\.currentScript\?\.src",
            "document.currentScript && document.currentScript.src",
            content
        )

        # Pattern 2: More general optional chaining patterns that might appear
        # This catches patterns like obj?.prop or obj?.method()
        content = re.sub(
            r'(\w+)\?\.([\w\.]+)',
            r'\1 && \1.\2',
            content
        )

        # Pattern 3: Optional chaining with array access like obj?.['prop']
        content = re.sub(
            r'(\w+)\?\.\[([^\]]+)\]',
            r'\1 && \1[\2]',
            content
        )

        if content != original_content:
            with open(js_path, "w", encoding="utf-8") as f:
                f.write(content)
            print(f"Fixed optional chaining in {js_path}")
        else:
            print(f"No optional chaining patterns found in {js_path}")

    except Exception as e:
        print(f"Error fixing optional chaining in {js_path}: {e}")
        # Don't fail the build, just warn
        return None

    return None

def create_template_zip(env, js, wasm, side):
    binary_name = "godot.editor" if env.editor_build else "godot"
    zip_dir = env.Dir(env.GetTemplateZipPath())
    in_files = [
        js,
        wasm,
        "#platform/web/js/libs/audio.worklet.js",
        "#platform/web/js/libs/audio.position.worklet.js",
    ]
    out_files = [
        zip_dir.File(binary_name + ".js"),
        zip_dir.File(binary_name + ".wasm"),
        zip_dir.File(binary_name + ".audio.worklet.js"),
        zip_dir.File(binary_name + ".audio.position.worklet.js"),
    ]
    # Dynamic linking (extensions) specific.
    if env["dlink_enabled"]:
        in_files.append(side)  # Side wasm (contains the actual Godot code).
        out_files.append(zip_dir.File(binary_name + ".side.wasm"))

    service_worker = "#misc/dist/html/service-worker.js"

    if env.editor_build:
        # HTML
        html = "#misc/dist/html/editor.html"
        cache = [
            "godot.editor.html",
            "offline.html",
            "godot.editor.js",
            "godot.editor.audio.worklet.js",
            "godot.editor.audio.position.worklet.js",
            "logo.svg",
            "favicon.png",
        ]
        opt_cache = ["godot.editor.wasm"]
        subst_dict = {
            "___GODOT_VERSION___": get_build_version(False),
            "___GODOT_NAME___": "GodotEngine",
            "___GODOT_CACHE___": json.dumps(cache),
            "___GODOT_OPT_CACHE___": json.dumps(opt_cache),
            "___GODOT_OFFLINE_PAGE___": "offline.html",
            "___GODOT_THREADS_ENABLED___": "true" if env["threads"] else "false",
            "___GODOT_ENSURE_CROSSORIGIN_ISOLATION_HEADERS___": "true",
        }
        html = env.Substfile(target="#bin/godot${PROGSUFFIX}.html", source=html, SUBST_DICT=subst_dict)
        in_files.append(html)
        out_files.append(zip_dir.File(binary_name + ".html"))
        # And logo/favicon
        in_files.append("#misc/dist/html/logo.svg")
        out_files.append(zip_dir.File("logo.svg"))
        in_files.append("#icon.png")
        out_files.append(zip_dir.File("favicon.png"))
        # PWA
        service_worker = env.Substfile(
            target="#bin/godot${PROGSUFFIX}.service.worker.js",
            source=service_worker,
            SUBST_DICT=subst_dict,
        )
        in_files.append(service_worker)
        out_files.append(zip_dir.File("service.worker.js"))
        in_files.append("#misc/dist/html/manifest.json")
        out_files.append(zip_dir.File("manifest.json"))
        in_files.append("#misc/dist/html/offline.html")
        out_files.append(zip_dir.File("offline.html"))
    else:
        # HTML
        in_files.append("#misc/dist/html/full-size.html")
        out_files.append(zip_dir.File(binary_name + ".html"))
        in_files.append(service_worker)
        out_files.append(zip_dir.File(binary_name + ".service.worker.js"))
        in_files.append("#misc/dist/html/offline-export.html")
        out_files.append(zip_dir.File("godot.offline.html"))

    zip_files = env.InstallAs(out_files, in_files)

    if env["arch"] == "wasm32":
        # Apply the optional chaining fix to the JS file before zipping
        # zip_files[0] is the JS file.
        # And we only do this for "wasm32" to support older browsers.
        env.AddPostAction(zip_files[0], fix_optional_chaining)

    env.Zip(
        "#bin/godot",
        zip_files,
        ZIPROOT=zip_dir,
        ZIPSUFFIX="${PROGSUFFIX}${ZIPSUFFIX}",
    )


def get_template_zip_path(env):
    return "#bin/.web_zip"


def add_js_libraries(env, libraries):
    env.Append(JS_LIBS=env.File(libraries))


def add_js_pre(env, js_pre):
    env.Append(JS_PRE=env.File(js_pre))


def add_js_post(env, js_post):
    env.Append(JS_POST=env.File(js_post))


def add_js_externs(env, externs):
    env.Append(JS_EXTERNS=env.File(externs))
